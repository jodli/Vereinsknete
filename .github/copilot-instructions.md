# VereinsKnete Copilot Instructions

## Project Overview
VereinsKnete is a single-user web application for freelance service providers (sports instructors) to track billable hours and generate invoices. This is a fullstack Rust + React application designed for local deployment.

## Architecture & Key Patterns

### Backend (Rust + Actix-web)
- **Layered architecture**: `handlers` → `services` → `models` + database
- **Database**: SQLite with Diesel ORM, migrations in `backend/migrations/`
- **Error handling**: Custom `AppError` types, use `web::block()` for async database operations
- **Modular design**: Each entity (client, session, invoice, user_profile) has its own handler/service/model files

### Frontend (React + TypeScript)
- **Routing**: React Router with page-based structure in `src/pages/`
- **API layer**: Centralized in `src/services/api.ts` with typed fetch functions
- **i18n**: German-first with `useLanguage()` hook, translations in `src/i18n/`
- **UI components**: Reusable components in `src/components/UI.tsx`
- **Styling**: Tailwind CSS with HeroIcons

### Data Flow
API endpoints follow RESTful patterns: `/api/{entity}` with standard CRUD operations. The frontend uses typed interfaces (see `src/types/index.ts`) that mirror backend models.

## Development Workflow

### Quick Start
```bash
# Use the development script for parallel backend/frontend
./dev.sh  # Starts tmux session with both servers

# Manual startup:
cd backend && cargo run          # Backend on :8080
cd frontend && npm start         # Frontend on :3000
```

### Database Management
```bash
cd backend
diesel migration run --database-url=database.sqlite
# SQLite database file is committed for single-user convenience
```

### Building & Deployment
- **Docker**: Multi-stage build combining Rust backend + React frontend
- **Production**: Single binary serves static files, controlled by `RUST_ENV` environment variable

## Project-Specific Conventions

### Backend Patterns
- **Database connections**: Use `DbPool` type, always call `pool.get().expect("Failed to get DB connection")`
- **Error propagation**: Services return `Result<T, diesel::result::Error>`, handlers convert to `AppError`
- **Request handling**: Use `web::block()` for database operations to avoid blocking async runtime
- **Models**: Separate `New{Entity}` and `Update{Entity}` structs for create/update operations

### Frontend Patterns
- **Component structure**: Export functional components with TypeScript interfaces
- **Data fetching**: Use `useState` + `useEffect` pattern, handle loading/error states consistently
- **API integration**: All endpoints return consistent error format, handle 404s explicitly
- **Forms**: Use controlled components with form data types (e.g., `ClientFormData`)

### Invoice Generation
Critical business logic: Invoice numbers use format `YYYY-NNNN` with auto-incrementing sequence per year. PDF generation uses `genpdf` crate with embedded fonts.

### Key Dependencies
- **Backend**: `actix-web`, `diesel`, `genpdf`, `chrono`, `serde`
- **Frontend**: `react-router-dom`, `react-datepicker`, `@heroicons/react`

## File Locations
- **Database schema**: `backend/src/schema.rs` (auto-generated by Diesel)
- **API routes**: Configured in `backend/src/main.rs` with `/api` prefix
- **Type definitions**: `frontend/src/types/index.ts` - keep synchronized with backend models
- **Environment config**: Development uses local `.env`, production uses container environment

## Testing & Debugging
- **Backend logs**: Use `log::info!()` macros, controlled by `RUST_LOG` environment variable
- **Frontend errors**: Console errors are logged in API service layer
- **Database inspection**: Use `sqlite3` CLI on `backend/vereinsknete.db` file
